---
title: "CQCD_small_big_d"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

This markdown is to show that the CQCD algorithm works well when `d` is relatively small, e.g., 20.

## Preparation

```{r install the moderated GpGp Pkg}
rm(list = ls())
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
library(GpGp)
library(mvtnorm)
library(ggplot2)
library(RColorBrewer)
source("CQCD.R")
set.seed(123)
```

## Generate training samples

```{r generate training sample}
n <- 1e4
d <- 20
m <- 100
r <- c(10, 5, 2, 1, 0.5, rep(0, d - 5))
sigmasq <- 1.0 # variance
tausq <- 0.05^2 # nugget
locs <- lhs::randomLHS(n, d)
locs <- locs * outer(rep(sqrt(n), n), 1 / sqrt(colSums(locs^2)))
covM <- GpGp::matern25_scaledim_relevance(c(sigmasq, r, tausq), locs)
cholM <- t(chol(covM))
y <- as.vector(cholM %*% rnorm(n))
X <- matrix(1, n, 1)
rm(covM, cholM)
```

## Optimization

Set initial values and lower bounds. 
```{r init val and lower bounds}
sigmasqInit <- 0.25
tausqInit <- 0.01^2
relInit <- 0.1
theta <- c(sigmasqInit, rep(relInit, d), tausqInit)
lb <- c(0.01^2, rep(0, d), 0.01^2) 
arg_check <- function(x) {sum(x[2 : (d + 1)]) > 1e-4}
```

Optimization with CQCD.
```{r optimization with CQCD}
maxIter <- 8
rslt <- list()
for(crtIter in c(1 : maxIter))
{
  # reorder at each iteration
  locsScal <- locs %*% diag(theta[2 : (d + 1)])
  odr <- GpGp::order_maxmin(locsScal)
  yOdr <- y[odr]
  locsOdr <- locs[odr, ]
  locsScalOdr <- locsScal[odr, ]
  XOdr <- X[odr, , drop = F]
  NNarray <- GpGp::find_ordered_nn(locsScalOdr, m = m)
  # Define functions for parameter estimation in the outer loop
  objfun <- function(theta){
    GpGp::vecchia_profbeta_loglik(theta, "matern25_scaledim_relevance",
                                            yOdr, XOdr, locsOdr, NNarray)
  }
  objfun_gdfm <- function(theta){
    GpGp::vecchia_profbeta_loglik_grad_info(theta,
                                            "matern25_scaledim_relevance",
                                            yOdr, XOdr, locsOdr, NNarray)
  }
  quadObj <- CQCD(objfun, objfun_gdfm, theta, 
                  maxIterOut = 1,
                  maxIterIn = 40, lb = lb, arg_check = arg_check)
  theta <- quadObj$covparms
  rslt[[crtIter]] <- theta
}
cat(theta, "\n")
```

## Plot the result

```{r plot the result}
niter <- crtIter
mydf <- matrix(NA, (niter + 1) * d, 4)
colnames(mydf) <- c("iter", "val", "varid", "true_val")
for(i in 1 : d)
{
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 1] <- c(0 : niter)
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 2] <-
    c(relInit, sapply(rslt, function(x){x[i + 1]}))
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 3] <- i
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 4] <- r[i]
}
mydf <- as.data.frame(mydf)
mydf$true_val <- paste0("rel = ", mydf$true_val)

ggplot(data = mydf, aes(x = iter, y = val, group = varid, col = factor(true_val))) +
  geom_line() +
  xlab("iteration number") +
  ylab("relevance parameters") +
  # scale_color_manual(values=c("red", "black", "green"))
  scale_color_brewer(palette="Dark2") +
  theme(legend.title = element_blank(), legend.position="right")
ggsave("CQCD_small_d.pdf", width = 6, height = 3.375)
```
