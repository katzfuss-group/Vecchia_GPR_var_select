---
title: "summary16"
author: "Jian Cao"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview

This markdown is to show that the `quad_cdsc` can unselect variables.

```{r Preparation}
rm(list = ls())
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
library(GpGp)
source("quad_cdsc_L1.R")
```
```{r simulate GP in d dimensions}
set.seed(123)
n <- 1e4
d <- 20
r <- c(1, 1, 1, 1, 1, rep(0, d - 5))
sigmasq <- 1.0 # variance
tausq <- 0.05^2 # nugget
locs <- lhs::randomLHS(n, d)
locs <- locs * outer(rep(sqrt(n), n), 1 / sqrt(colSums(locs^2)))
covM <- GpGp::matern25_scaledim_relevance(c(sigmasq, r, tausq), locs)
cholM <- t(chol(covM))
y <- as.vector(cholM %*% rnorm(n))
X <- matrix(1, n, 1)
rm(covM, cholM)
```

```{r conditioning size}
m <- 100
```

```{r init val for non-rel parms-penalty parms-opt bounds}
sigmasqInit <- 0.25
tausqInit <- 0.01^2
rInit <- rep(0.5, d)
lambda <- 0
lb_nonrel_parms <- c(0.01^2, 0.01^2) 
```

## Fit with relevance
```{r}
startTime <- Sys.time()
crtIter <- 1
maxIter <- 100
theta <- c(sigmasqInit, rInit, tausqInit)
locsScal <- locs %*% diag(r)
odr <- GpGp::order_maxmin(locsScal)
yOdr <- y[odr]
locsScalOdr <- locsScal[odr, , drop = F]
locsOdr <- locs[odr, , drop = F]
XOdr <- X[odr, , drop = F]
NNarray <- GpGp::find_ordered_nn(locsScalOdr, m = m)
# Define functions for parameter estimation in the outer loop
objfun <- function(theta, locsOdr){
  GpGp::vecchia_profbeta_loglik(theta, "matern25_scaledim_relevance",
                                          yOdr, XOdr, locsOdr, 
                                          NNarray)
}
objfun_gdfm <- function(theta, locsOdr){
  GpGp::vecchia_profbeta_loglik_grad_info(theta, "matern25_scaledim_relevance",
                                          yOdr, XOdr, locsOdr, 
                                          NNarray)
}
rslt <- list()
for(crtIter in 1 : 20)
{
  theta <- quad_cdsc_L1(objfun, objfun_gdfm, locsOdr, 1, theta, lambda, 1e-3, 
                        silent = T, 
                        max_iter = 1, 
                        max_iter2 = 100, 
                        lb_nonrel_parms = lb_nonrel_parms)$covparms
  cat("quad_cdsc_L1 fit iter", crtIter, ": estimated parms = ", theta, "\n")
  rslt[[crtIter]] <- theta
  if(crtIter > 1 && sum(abs(rslt[[crtIter]] - rslt[[crtIter - 1]])) < 1e-4)
    break
}
endTime <- Sys.time()
cat("Time used for final estimation is", as.numeric(difftime(endTime, startTime, units = "secs")), "seconds\n")
```
## Plot the result
```{r}
library(ggplot2)
library(RColorBrewer)
niter <- crtIter
mydf <- matrix(NA, (niter + 1) * d, 4)
colnames(mydf) <- c("iter", "val", "varid", "col")
for(i in 1 : d)
{
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 1] <- c(0 : niter)
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 2] <-
    c(rInit[i], sapply(rslt, function(x){x[i + 1]}))
  mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 3] <- i
  if(r[i] > 0)
    mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 4] <- 1
  else
    mydf[((i - 1) * (niter + 1) + 1) : (i * (niter + 1)), 4] <- 2
}
mydf <- as.data.frame(mydf)
mydf$val <- mydf$val
mydf$col[mydf$col == 1] <- "true"
mydf$col[mydf$col == 2] <- "false"
ggplot(data = mydf, aes(x = iter, y = val, group = varid, col = factor(col))) +
  geom_line() +
  # scale_y_continuous(trans = "log2") +
  xlab("iteration number") +
  ylab("relevance parameters") +
  # scale_color_manual(values=c("red", "black", "green"))
  scale_color_brewer(palette="Dark2") +
  theme(legend.title = element_blank(), legend.position="right")
ggsave("unselect_var.pdf", width = 6, height = 3.375)
cat("Number of unselected variabels:", 
    sum(mydf$val[(niter + 1) * c(1 : d)] == 0),
    "out of", d - 5, "false variables\n")
```











