---
title: "min_batch_size"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
```

## Goal

Correct selection ratio v.s. mini-batch size.
```{r libs}
rm(list = ls())
library(GpGp)
library(lhs)
set.seed(123)
```

## Simulation

Simulate GP.
```{r simulate GP, eval = T}
n <- 5e3
d <- 1e3
m <- 100
rSq <- c(10, 5, 2, 1, 0.5, rep(0, d - 5))^2
sigmasq <- 1.0 # variance
tausq <- 0.05^2 # nugget
locs <- randomLHS(n, d)
locs <- locs * outer(rep(sqrt(n), n), 
                     1 / sqrt(colSums(locs^2)))
covM <- matern25_scaledim_sqrelevance(c(sigmasq, rSq, tausq), locs)
cholM <- t(chol(covM))
y <- as.vector(cholM %*% rnorm(n))
rm(covM, cholM)
```

Function for selection. 
```{r check select func, eval = T}
select_idx <- function(theta, k, bsz, niter)
{
  rSq <- theta[2 : (d + 1)]
  idxLocs <- which(rSq > 0)
  rSqRel <- rSq[idxLocs] 
  locsRel <- locs[, idxLocs, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(rSqRel), length(rSqRel), length(rSqRel))
  odr <- order_maxmin(locsRelScal)
  yOdr <- y[odr]
  locsRelScalOdr <- locsRelScal[odr, , drop = F]
  locsOdr <- locs[odr, , drop = F]
  NNarray <- find_ordered_nn(locsRelScalOdr, m = m)
  odrIter <- matrix(NA, niter, k)
  for(i in 1 : niter)
  {
    batchIdx <- sample(1 : n, bsz, replace = F)
    likobj <- vecchia_meanzero_loglik_grad_info(theta, 
                                                "matern25_scaledim_sqrelevance",
                                                yOdr, locsOdr, 
                                                NNarray[batchIdx, , drop = F])
    rSqGrad <- likobj$grad[2 : (d + 1)]
    odrIter[i, ] <- order(rSqGrad, decreasing = T)[1 : k]
  }
  odrIter
}
```

Simulation parameters.
```{r sim parms, eval = T}
niter <- 100
bszVec <- c(1 : 10) * 100
idxPredT <- which(rSq > 0)
dT <- length(idxPredT)
```

Simulation loop.
```{r sim, eval = T}
rslt <- matrix(NA, length(bszVec), dT)
for(i in 1 : length(bszVec))
{
  bsz <- bszVec[i]
  for(j in 1 : dT)
  {
    if(j == 1){
      theta <- c(sigmasq, rep(1e-8, d), tausq)
    }else{
      rSqCrt <- rep(0, d)
      rSqCrt[idxPredT[1 : (j - 1)]] <- rSq[idxPredT[1 : (j - 1)]]
      theta <- c(sigmasq, rSqCrt, tausq)
    }
    idxMat <- select_idx(theta, dT + 1 - j, bsz, niter)
    ratioT <- mean(apply(idxMat, 1, function(x){
      length(intersect(x, idxPredT[j : dT])) / (dT + 1 - j)}))
    rslt[i, j] <- ratioT
    cat("bsz = ", bsz, "nselected = ", j - 1, "ratio = ", ratioT, "\n")
  }
}
```

Save the results.
```{r save the result, eval = T}
save(list = c("n", "d", "m", "niter", "bszVec", "rSq", "sigmasq", "tausq", 
              "rslt"), 
     file = paste0("min_batch_size.RData"))
```

## Plots

Load libraries for plotting.
```{r lib for plotting, eval = F}
library(ggplot2)
library(RColorBrewer)
library(scales)
library(reshape)
```

Dataframe.
```{r build df, eval = F}
dfRatioT <- matrix(NA, nrow(rslt) * ncol(rslt), 3)
for(j in 1 : ncol(rslt))
{
  idx <- ((j - 1) * nrow(rslt) + 1) : (j * nrow(rslt))
  dfRatioT[idx, 1] <- bszVec
  dfRatioT[idx, 2] <- rslt[, j]
  dfRatioT[idx, 3] <- j - 1
}
dfRatioT <- as.data.frame(dfRatioT)
colnames(dfRatioT) <- c("batch size", "correct ratio", "#selected predictors")
```

Plot.
```{r plot, eval = F}
ggplot(data = dfRatioT) +
  geom_line(aes(x = "batch size", y = "correct ratio", 
                col = "#selected predictors"), lwd = 1.5) +
  scale_color_manual(breaks = unique(dfRatioT[["#selected predictors"]]),
                     values = rainbow(length(unique(
                       dfRatioT[["#selected predictors"]])))) +
  theme(legend.position = "none",
        axis.title.y = element_blank(),
        axis.text=element_text(size = 12),
        axis.title=element_text(size = 12))
```









