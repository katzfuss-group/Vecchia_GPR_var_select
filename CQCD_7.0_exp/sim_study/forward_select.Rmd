---
title: "Forward Selection"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Method 
Use scaled Vecchia and Fisher scoring. OOS score is used to select the best model from the pool.

## Preparation
Clean the environment
```{r clean environment}
rm(list = ls())
```
Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
library(GpGp)
library(FNN)
library(scoringRules)
library(parallel)
if(file.exists("CQCD.R")){
  source("CQCD.R")
}else{
  source("../CQCD.R")
}
args <- commandArgs(trailingOnly = T)
if(length(args) != 3)
  stop("Wrong number of input args\n")
dataInFile <- args[1]
if(file.exists(dataInFile)){
  load(dataInFile)
}else{
  load(paste0("../../sim_study_data_gen/", dataInFile))
}
source("fisher_scoring.R")
set.seed(123)
```
Divide observations.
```{r divide GP obs, eval = T}
m <- 100
k <- 3
nOOS <- 5e3
nTest <- 5e3
nTrain <- as.numeric(args[2])
dTrain <- as.numeric(args[3])
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsOOS <- locs[(nTrain + 1) : (nTrain + nOOS), 1 : dTrain, drop = F]
locsTest <- locs[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest), 1 : dTrain, 
                 drop = F]
yTrain <- y[1 : nTrain]
yOOS <- y[(nTrain + 1) : (nTrain + nOOS)]
yTest <- y[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest)]
```
Function for computing the approximate OOS score, assuming the squared relevance parameterized Matern25 kernel.
```{r OOS score, eval = T}
OOS_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsOOS)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yOOS)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nOOS), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nOOS))
  mus <- rep(NA, nOOS)
  sds <- rep(NA, nOOS)
  for(i in 1 : nOOS){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yOOS, mean = mus, sd = sds))
}
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsTest)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yTest)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nTest), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nTest))
  mus <- rep(NA, nTest)
  sds <- rep(NA, nTest)
  for(i in 1 : nTest){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yTest, mean = mus, sd = sds))
}
```

## Method specific

Link and response transforms
```{r link and response, eval = T}
link_func <- log
resp_func <- exp
dresp_func <- exp
```
Function for model fitting given predictor indices. `theta` stores the warm-start values after **transformation**. 
```{r model fit, eval = T}
maxIter <- 100
model_fit <- function(locsIdx)
{
  locsFit <- locsTrain[, locsIdx, drop = F]
  thetaFit <- theta[c(1, locsIdx + 1, dTrain + 2)]
  locsFitScal <- locsFit %*% 
      diag(sqrt(resp_func(thetaFit[2 : (1 + length(locsIdx))])), 
           length(locsIdx), length(locsIdx))
  odr <- order_maxmin(locsFitScal)
  yOdr <- yTrain[odr]
  locsFitScalOdr <- locsFitScal[odr, , drop = F]
  locsFitOdr <- locsFit[odr, , drop = F]
  NNarray <- GpGp::find_ordered_nn(locsFitScalOdr, m = m)
  
  objfun <- function(thetaTrans){
    likobj <- 
      vecchia_meanzero_loglik_grad_info(resp_func(thetaTrans), 
                                        "matern25_scaledim_sqrelevance",
                                        yOdr, locsFitOdr, 
                                        NNarray)
      likobj$loglik <- -likobj$loglik
      likobj$grad <- -c(likobj$grad) * dresp_func(thetaTrans)
      likobj$info <- likobj$info * outer(dresp_func(thetaTrans),
                                         dresp_func(thetaTrans))
      return(likobj)
  }
  
  FisherObj <- fisher_scoring(objfun, thetaFit, resp_func, T, 1e-4, maxIter)
  thetaFit <- FisherObj$logparms
  OOSScore <- OOS_score(theta = resp_func(thetaFit), idxLocsRel = locsIdx)
  list(theta = thetaFit, score = OOSScore)
}
```

Init `theta`.
```{r Init theta, eval = T}
theta <- link_func(c(0.25, rep(1.0, dTrain), 0.01))
idxSet <- list()
thetaSet <- list()
scoreSet <- list()
selectIdx <- c()
```
Loop over lambda.
```{r loop over lambda, eval = T}
startTime <- Sys.time()
for(i in 1 : dTrain)
{
  cat("\n====================================\n")
  unselectIdx <- setdiff(1 : dTrain, selectIdx)
  idxList <- lapply(unselectIdx, function(x){c(selectIdx, x)})
  models <- mclapply(idxList, model_fit, mc.cores = 8)
  scores <- unlist(lapply(models, function(x){x$score}))
  idxBest <- which.min(scores)
  cat("i =", i, "idxBest is", idxList[[idxBest]], "\n")
  # Store results
  idxSet[[i]] <- idxList[[idxBest]] + 1
  thetaSet[[i]] <- rep(0, dTrain + 2)
  thetaSet[[i]][c(1, idxSet[[i]], dTrain + 2)] <- 
    resp_func(models[[idxBest]]$theta)
  scoreSet[[i]] <- models[[idxBest]]$score
  theta[c(1, idxSet[[i]], dTrain + 2)] <- models[[idxBest]]$theta
  selectIdx <- idxList[[idxBest]]
  if(i > 1 && scoreSet[[i]] / scoreSet[[i - 1]] > 0.99 &&
     length(setdiff(idxSet[[i]], idxSet[[i - 1]])) > 0 && 
     sum(thetaSet[[i]][2 : (dTrain + 1)]) > 0.1)
    break
}
endTime <- Sys.time()
timeObj <- endTime - startTime
timeObj
```

```{r save the result, eval = T}
if(grepl("dep", dataInFile, ignore.case = T)){
  dataOutFile <- paste0("forward_select_dep_", nTrain, "_", dTrain, ".RData")
}else
  dataOutFile <- paste0("forward_select_", nTrain, "_", dTrain, ".RData")
save(list = c("dTrain", "idxSet", "thetaSet", "scoreSet",
              "nTrain", "timeObj"), 
     file = dataOutFile)
```
