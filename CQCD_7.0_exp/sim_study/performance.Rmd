---
title: "performance"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

Produce metrics for the estimation results in the simulation study.

```{r clean environment}
rm(list = ls())
```

## Implementation

Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
library(GpGp)
library(FNN)
library(scoringRules)
library(parallel)
args <- commandArgs(trailingOnly = T)
if(length(args) != 3)
  stop("Wrong number of input args\n")
rsltFile <- args[1]
dataFile <- args[2]
dataOutFile <- args[3]
if(file.exists(dataFile)){
  load(dataFile)
}else{
  load(paste0("../../sim_study_data_gen/", dataFile))
}
if(file.exists(rsltFile)){
  load(rsltFile)  
}else{
  cat(NA, NA, NA, NA, sep = ",", file = dataOutFile, append = T)
  cat("\n", file = dataOutFile, append = T)
  q()
}

set.seed(123)
```

Divide observations.
```{r divide GP obs, eval = T}
m <- 100
n <- length(y)
nTest <- 5e3
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsTest <- locs[(n - nTest + 1) : n, 1 : dTrain, drop = F]
yTrain <- y[1 : (n - nTest)]
yTest <- y[(n - nTest + 1) : n]
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(theta, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsTest)[, idxLocsRel, drop = F]
  thetaRel <- theta[c(1, idxLocsRel + 1, dTrain + 2)]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yTest)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nTest), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nTest))
  mus <- rep(NA, nTest)
  sds <- rep(NA, nTest)
  for(i in 1 : nTest){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  
  mean(crps_norm(y = yTest, mean = mus, sd = sds))
}
```

Measurements
```{r CRPS, eval = T}
idxOpt <- max(length(thetaSet) - 1, 1)
CRPS <- test_score(thetaSet[[idxOpt]], idxSet[[idxOpt]] - 1)
distance <- sum(abs(sqrt(thetaSet[[idxOpt]][2 : (dTrain + 1)]) - 
                      sqrt(rSq[1 : dTrain])))
nPred <- length(idxSet[[idxOpt]])
timeVal <- as.numeric(timeObj, units = "secs")
cat(CRPS, nPred, distance, timeVal, sep = ",", file = dataOutFile, append = T)
cat("\n", file = dataOutFile, append = T)
```

Output to latex format
```{r latex tbl, eval = F}
tbl <- as.matrix(read.csv("table.csv", header = F))
for(i in 1 : 3)
{
  if(i == 1){
    cat("\\multirow{8}{*}{$500$} &")
  }else if(i == 2){
    cat("\\multirow{8}{*}{$5{,}000$} &")
  }else{
    cat("\\multirow{8}{*}{$25{,}000$} &")
  }
  tbl2 <- matrix(NA, 8, 8)
  tbl3 <- tbl[((i - 1) * 16 + 1) : (i * 16), ]
  for(j in 1 : 8)
  {
    tbl2[, j] = c(tbl3[((j - 1) * 2 + 1), ], tbl3[((j - 1) * 2 + 2), ])
  }
  for(i1 in 1 : nrow(tbl2))
  {
    if(i1 == 1)
      cat("\\multirow{4}{*}{I}")
    if(i1 == 5)
      cat("& \\multirow{4}{*}{D}")
    if((i1 - 1) %% 4 > 0)
      cat("& ")
    for(j1 in 1 : ncol(tbl2))
    {
      if(is.na(tbl2[i1, j1])){
        cat("& N.A. ")
      }else{
        cat("&", signif(tbl2[i1, j1], digits = 2), "")
      }
    }
    cat("\\\\")
    if((i1) %% 8 == 0){
      cat(" \\cline{1-10}")
    }else if((i1) %% 4 == 0){
      cat(" \\cline{3-10}")
    }
    cat("\n")
  }
}
```

## Plot

Build dataframe.
```{r build df, eval = F}
nVec <- c(500, 5000, 25000)
dVec <- c(100, 1000)
mtdVec <- c("REG", "Fisher", "FWD", "PGPR")
depVec <- c("I", "D")
meaVec <- c("CRPS", "nSel", "Dist", "Time")
nNum <- length(nVec)
dNum <- length(dVec)
mtdNum <- length(mtdVec)
depNum <- length(depVec)
meaNum <- length(meaVec)
dfMat <- matrix(NA, nNum * dNum * mtdNum * depNum * meaNum, 6)
idx <- 1
idx2 <- 1
for(inNum in 1 : nNum){
  for(idNum in 1 : dNum){
    for(imtdNum in 1 : mtdNum){
      # read 2 lines, 8 values, each inner iteration
      dfMat[idx : (idx + 2 * meaNum - 1), 1] <- nVec[inNum]
      dfMat[idx : (idx + 2 * meaNum - 1), 2] <- dVec[idNum]
      dfMat[idx : (idx + 2 * meaNum - 1), 3] <- imtdNum
      dfMat[idx : (idx + 2 * meaNum - 1), 4] <- c(rep(1, meaNum), 
                                     rep(2, meaNum)) # 1 Ind 2 Dep
      dfMat[idx : (idx + 2 * meaNum - 1), 5] <- rep(1 : meaNum, 2)
      dfMat[idx : (idx + 2 * meaNum - 1), 6] <- c(t(tbl[c(idx2, idx2 + 1), ]))
      idx <- idx + 2 * meaNum
      idx2 <- idx2 + 2
    }
  }
}

df <- as.data.frame(dfMat)
df[, 1] <- paste0("(", df[, 1], ", ", df[, 2], ")")
df <- df[, c(1, 3 : 6)]
df[, 2] <- mtdVec[df[, 2]]
df[, 3] <- depVec[df[, 3]]
df[, 4] <- meaVec[df[, 4]]
colnames(df) <- c("nd", "method", "dependence", "metric", "val")
df
```

Plot
```{r plot, eval = F}
library(ggplot2)
library(RColorBrewer)
library(scales)
library(reshape)
for(i in 1 : meaNum){
  meaName <- meaVec[i]
  dfSub <- df[df$metric == meaName, ]
  myplot <- ggplot(data = dfSub, aes(x = nd, y = val, 
                                 col = method, shape = dependence,
                                 group = interaction(method, dependence))) +
    geom_point(alpha = 0.8) +
    ylab(meaName) + 
    xlab("(n, d)") +
    scale_y_continuous(trans = pseudo_log_trans(sigma = 
                                                  min(dfSub$val, na.rm = T))) 
  print(myplot)
  ggsave(paste0(meaName, ".pdf"), width = 7, height = 5)
}

```

Performance metrics of `REG` under different `m`. 
```{r metrics REG wrt m, eval = F}
tbl4m <- read.csv("table.csv", header = F)
dfMat <- matrix(NA, 240, 6)
meaVec <- c("CRPS", "nSel", "Dist", "Time")
depVec <- c("I", "D")
idx <- 1
idx2 <- 1
for(n in c(500, 5000, 25000))
  for(d in c(100, 1000))
    for(m in c(10, 20, 50, 100, 200)){
      dfMat[idx : (idx + 7), 1] <- n
      dfMat[idx : (idx + 7), 2] <- d
      dfMat[idx : (idx + 7), 3] <- m
      dfMat[idx : (idx + 7), 4] <- c(rep(1, 4), rep(2, 4))
      dfMat[idx : (idx + 7), 5] <- rep(1 : 4, 2)
      dfMat[idx : (idx + 7), 6] <- c(t(tbl4m[c(idx2, idx2 + 1), ]))
      idx <- idx + 8
      idx2 <- idx2 + 2
    }
df <- as.data.frame(dfMat)
df[, 1] <- paste0("(", df[, 1], ", ", df[, 2], ")")
df <- df[, c(1, 3 : 6)]
df[, 3] <- depVec[df[, 3]]
df[, 4] <- meaVec[df[, 4]]
colnames(df) <- c("nd", "m", "dependence", "metric", "val")
df$m <- as.factor(df$m)
df$nd <- factor(df$nd, levels = unique(df$nd))

library(ggplot2)
library(RColorBrewer)
library(scales)
library(reshape)
for(i in 1 : length(meaVec)){
  meaName <- meaVec[i]
  dfSub <- df[df$metric == meaName, ]
  myplot <- ggplot(data = dfSub, aes(x = nd, y = val, 
                                 col = m, shape = dependence,
                                 group = interaction(m, dependence))) +
    geom_point(alpha = 0.8) +
    ylab(meaName) + 
    xlab("(n, d)")
  print(myplot)
  ggsave(paste0(meaName, ".pdf"), width = 7, height = 5)
}
```



