---
title: "performance"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

Produce metrics for the estimation results in the simulation study.

```{r clean environment}
rm(list = ls())
```

## Implementation

Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
library(GpGp)
library(FNN)
library(scoringRules)
library(parallel)
source("vecchia_scaled.R")
args <- commandArgs(trailingOnly = T)
if(length(args) != 3)
  stop("Wrong number of input args\n")
rsltFile <- args[1]
dataFile <- args[2]
dataOutFile <- args[3]
if(file.exists(paste0("data/",dataFile))){
  load(paste0("data/",dataFile))
}else{
  load(paste0("../../sim_study_data_gen/", dataFile))
}
if(file.exists(paste0("data/",rsltFile))){
  load(paste0("data/",rsltFile))  
}else{
  cat(NA, NA, NA, NA, sep = ",", file = dataOutFile, append = T)
  cat("\n", file = dataOutFile, append = T)
  q()
}

set.seed(123)
```

Divide observations.
```{r divide GP obs, eval = T}
m <- 100
n <- length(y)
nTest <- 5e3
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsTest <- locs[(n - nTest + 1) : n, 1 : dTrain, drop = F]
yTrain <- y[1 : nTrain]
yTest <- y[(n - nTest + 1) : n]
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(theta, idxLocsRel)
{
  thetaRel <- theta[c(1, idxLocsRel + 1, dTrain + 2)]
  fit <- list(y = yTrain, locs = locsTrain[, idxLocsRel, drop = F], 
              covparms = thetaRel, 
              X = matrix(0, nTrain, 1), 
              betahat = 0, covfun_name = "matern25_scaledim_sqrelevance", 
              trend = "zero")
  cat(system.time(
    predObj <- predictions_scaled(fit, locsTest[, idxLocsRel, drop = F], m, 
                                T, 1e3)), "\n")
  vars <- apply(predObj$samples, 1, var)
  es <- es_sample(yTest, predObj$samples)
  CRPScore <- mean(crps_norm(y = yTest, mean = predObj$means, sd = sqrt(vars)))
  return(list(CRPScore = CRPScore, es = es))
}
```

Measurements
```{r CRPS, eval = T}
idxOpt <- max(length(thetaSet) - 1, 1)
testObj <- test_score(thetaSet[[idxOpt]], idxSet[[idxOpt]] - 1)
CRPS <- testObj$CRPScore
es <- testObj$es
falseP <- (length(idxSet[[idxOpt]]) - 
             length(intersect(idxSet[[idxOpt]], 2 : (d0 + 1)))) / 
  length(idxSet[[idxOpt]])
falseN <- (d0 - length(intersect(idxSet[[idxOpt]], 2 : (d0 + 1)))) / 
  (dTrain - length(idxSet[[idxOpt]]))
if(is.na(falseN))
  falseN <- 0
timeVal <- as.numeric(timeObj, units = "secs")
cat(CRPS, es, falseP, falseN, timeVal, sep = ",", file = dataOutFile, 
    append = T)
cat("\n", file = dataOutFile, append = T)
```


## Plot

Read data from `table.csv` and build dataframe
```{r read data, eval = F}
meaVec <- c("CRPS", "Dist", "FPos", "FNeg", "Time")
depVec <- c("I", "D")
mtdVec <- c("REG", "Fisher", "FWD", "PGPR")
nVec <- c(500, 5000, 25000)
dVec <- c(100, 1000)
meaNum <- length(meaVec)
depNum <- length(depVec)
mtdNum <- length(mtdVec)
nNum <- length(nVec)
dNum <- length(dVec)
tbl <- read.csv("table.csv", header = F)
dfMat <- matrix(NA, meaNum * depNum * mtdNum * nNum * dNum, 6)

idx <- 1
idx2 <- 1
for(n in nVec)
  for(d in dVec)
    for(imtd in 1 : mtdNum){
      dfMat[idx : (idx + 2 * meaNum - 1), 1] <- n
      dfMat[idx : (idx + 2 * meaNum - 1), 2] <- d
      dfMat[idx : (idx + 2 * meaNum - 1), 3] <- imtd
      dfMat[idx : (idx + 2 * meaNum - 1), 4] <- c(rep(1, meaNum), 
                                                  rep(2, meaNum)) # dependency
      dfMat[idx : (idx + 2 * meaNum - 1), 5] <- rep(1 : meaNum, 2) # measurement
      dfMat[idx : (idx + 2 * meaNum - 1), 6] <- c(t(tbl[c(idx2, idx2 + 1), ]))
      idx <- idx + 2 * meaNum
      idx2 <- idx2 + 2
    }
df <- as.data.frame(dfMat)
df[, 3] <- mtdVec[df[, 3]]
df[, 4] <- depVec[df[, 4]]
df[, 5] <- meaVec[df[, 5]]
colnames(df) <- c("n", "d", "mtd", "dependence", "measurement", "val")
df$n <- factor(df$n, levels = unique(df$n))
df$d <- factor(df$d, levels = unique(df$d))
df
```

```{r plot accuracy measurements, eval = F}
library(ggplot2)
library(RColorBrewer)
library(scales)
library(reshape)
library(patchwork)
rm(pltTtl)
for(mea in c("CRPS", "Dist", "FPos", "Time")) # row
  for(dep in c("I", "D"))
    for(dTmp in dVec){
      dfSub <- subset(df, measurement == mea & dependence == dep & d == dTmp)
      plt <- ggplot(data = dfSub, 
                    aes(x = n, y = val, col = mtd, shape = mtd, group = mtd)) +
        geom_point(size = 3) + 
        geom_line() +
        theme(text = element_text(size = 20), legend.title = element_blank())
      if(dep != "I" | dTmp != dVec[1]){
        plt <- plt + theme(axis.title.y = element_blank())
      }else
        plt <- plt + ylab(mea)
      if(mea != "Time"){
        plt <- plt + 
          theme(axis.title.x = element_blank(), 
                axis.ticks.x=element_blank(), axis.text.x=element_blank())
      }
      if(exists("pltTtl")){
        pltTtl <- pltTtl + plt
      }else
        pltTtl <- plt
    }
pltTtl + plot_layout(ncol = 4, guides = "collect")
ggsave("tmp.pdf", height = 10, width = 14)
```

```{r plot time measurements, eval = F}
dfTime <- df[df$measurement == "Time", ]
dfTime$n <- paste0("(", dfTime$n, ", ", dfTime$d, ")")
dfTime$n <- factor(dfTime$n, levels = unique(dfTime$n))
ggplot(data = dfTime, aes(x = n, y = val, col = mtd, shape = dependence, 
                         lty = mtd, group = interaction(mtd, dependence))) +
  geom_point() + 
  geom_line(alpha = 0.8) +
  ylab("time (s)") + 
  xlab("(n, d)") +
  scale_y_continuous(trans = pseudo_log_trans(sigma = 100), 
                     breaks = c(50, 100, 200, 500, 1e3, 5e3, 1e4, 4e4)) 
ggsave("sim_time.pdf", height = 5, width = 7)
```

