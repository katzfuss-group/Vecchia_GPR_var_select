---
title: "performance"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Goal

Produce metrics for the estimation results in the simulation study.

```{r clean environment}
rm(list = ls())
```

## Implementation

Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
library(GpGp)
library(FNN)
library(scoringRules)
library(parallel)
source("vecchia_scaled.R")
args <- commandArgs(trailingOnly = T)
if(length(args) != 3)
  stop("Wrong number of input args\n")
rsltFile <- args[1]
dataFile <- args[2]
dataOutFile <- args[3]
if(file.exists(paste0("dataIn/",dataFile))){
  load(paste0("dataIn/",dataFile))
}else{
  load(paste0("../../sim_study_data_gen/", dataFile))
}
if(file.exists(paste0("dataOut/",rsltFile))){
  load(paste0("dataOut/",rsltFile))  
}else{
  cat(NA, NA, NA, NA, sep = ",", file = dataOutFile, append = T)
  cat("\n", file = dataOutFile, append = T)
  q()
}

set.seed(123)
```

Divide observations.
```{r divide GP obs, eval = T}
m <- 100
n <- length(y)
nTest <- 5e3
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsTest <- locs[(n - nTest + 1) : n, 1 : dTrain, drop = F]
yTrain <- y[1 : nTrain]
yTest <- y[(n - nTest + 1) : n]
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(theta, idxLocsRel)
{
  thetaRel <- theta[c(1, idxLocsRel + 1, dTrain + 2)]
  fit <- list(y = yTrain, locs = locsTrain[, idxLocsRel, drop = F], 
              covparms = thetaRel, 
              X = matrix(0, nTrain, 1), 
              betahat = 0, covfun_name = "matern25_scaledim_sqrelevance", 
              trend = "zero")
  cat(system.time(
    predObj <- predictions_scaled(fit, locsTest[, idxLocsRel, drop = F], m, 
                                T, 1e3)), "\n")
  vars <- apply(predObj$samples, 1, var)
  es <- es_sample(yTest, predObj$samples)
  CRPScore <- mean(crps_norm(y = yTest, mean = predObj$means, sd = sqrt(vars)))
  pctgErr <- predObj$means / yTest - 1
  RMSPE <- sqrt(mean(pctgErr^2))
  return(list(CRPScore = CRPScore, es = es, RMSPE = RMSPE))
}
```

Measurements
```{r CRPS, eval = T}
idxOpt <- max(length(thetaSet) - 1, 1)
testObj <- test_score(thetaSet[[idxOpt]], idxSet[[idxOpt]] - 1)
CRPS <- testObj$CRPScore
es <- testObj$es
RMSPE <- testObj$RMSPE
falseP <- (length(idxSet[[idxOpt]]) - 
             length(intersect(idxSet[[idxOpt]], 2 : (d0 + 1)))) / 
  length(idxSet[[idxOpt]])
falseN <- (d0 - length(intersect(idxSet[[idxOpt]], 2 : (d0 + 1)))) / 
  (dTrain - length(idxSet[[idxOpt]]))
if(is.na(falseN))
  falseN <- 0
timeVal <- as.numeric(timeObj, units = "secs")
cat(CRPS, es, RMSPE, falseP, falseN, timeVal, sep = ",", file = dataOutFile, 
    append = T)
cat("\n", file = dataOutFile, append = T)
```


## Plot

Read data from `table.csv` and build dataframe
```{r read data, eval = F}
meaVec <- c("CRPS", "ES", "RMSPE", "FPos", "FNeg", "Time")
depVec <- c("I", "D")
mtdVec <- c("REG", "Fisher", "FWD", "PGPR")
nVec <- c(500, 5000, 25000)
dVec <- c(100, 1000)
meaNum <- length(meaVec)
depNum <- length(depVec)
mtdNum <- length(mtdVec)
nNum <- length(nVec)
dNum <- length(dVec)

rm(dfMat)
nrep <- 5
for(irep in 1 : nrep){
  idx <- 1
  idx2 <- 1
  tbl <- read.csv(paste0("table_", irep, ".csv"), header = F)
  dfMatTmp <- matrix(NA, meaNum * depNum * mtdNum * nNum * dNum, 6)
  for(n in nVec)
    for(d in dVec)
      for(imtd in 1 : mtdNum){
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 1] <- n
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 2] <- d
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 3] <- imtd
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 4] <- c(rep(1, meaNum), 
                                                    rep(2, meaNum)) # dependency
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 5] <- 
          rep(1 : meaNum, 2) # measurement
        dfMatTmp[idx : (idx + 2 * meaNum - 1), 6] <- 
          c(t(tbl[c(idx2, idx2 + 1), ]))
        idx <- idx + 2 * meaNum
        idx2 <- idx2 + 2
      }
  if(exists("dfMat"))
    dfMat[, 6] <- dfMat[, 6] + dfMatTmp[, 6]
  else
    dfMat <- dfMatTmp
}
dfMat[, 6] <- dfMat[, 6] / nrep

df <- as.data.frame(dfMat)
df[, 3] <- mtdVec[df[, 3]]
df[, 4] <- depVec[df[, 4]]
df[, 5] <- meaVec[df[, 5]]
colnames(df) <- c("n", "d", "mtd", "dependence", "measurement", "val")
df$n <- factor(df$n, levels = unique(df$n))
df$d <- factor(df$d, levels = unique(df$d))
df
```

```{r plot accuracy measurements, eval = F}
library(ggplot2)
library(RColorBrewer)
library(scales)
library(reshape)
library(patchwork)
rm(pltTtl)
for(mea in c("CRPS", "RMSPE", "FPos", "Time")) # row
# for(mea in c("CRPS", "FPos", "Time")) # row
  for(dTmp in dVec)
    for(dep in c("I", "D")){
      dfSub <- subset(df, measurement == mea & dependence == dep & d == dTmp)
      plt <- ggplot(data = dfSub, 
                    aes(x = n, y = val, col = mtd, shape = mtd, group = mtd)) +
        geom_point(size = 5) + 
        scale_shape(solid = FALSE) +
        geom_line() +
        theme(text = element_text(size = 20), legend.title = element_blank(),
              legend.key.height = unit(3, 'cm'))
      if(mea == "CRPS")
        plt <- plt + ggtitle(paste0(dTmp,  " ",
                                    switch(which(dep == c("I", "D")), 
                                           "ind", "dep"), " pred")) +
        scale_y_continuous(trans = pseudo_log_trans(sigma = 0.001))
      if(dep != "I" | dTmp != dVec[1]){
        plt <- plt + theme(axis.title.y = element_blank())
      }else
        plt <- plt + ylab(mea)
      if(mea != "Time"){
        plt <- plt + 
          theme(axis.title.x = element_blank(), 
                axis.ticks.x=element_blank(), axis.text.x=element_blank())
      }
      if(exists("pltTtl")){
        pltTtl <- pltTtl + plt
      }else
        pltTtl <- plt
    }
pltTtl + plot_layout(ncol = 4, guides = "collect")
ggsave("sim_result.pdf", height = 10, width = 14)
```

Try the bar plot.
```{r try bar plot, eval = F}
rm(pltTtl)
for(mea in c("CRPS", "ES", "FPos", "Time")) # row
# for(mea in c("CRPS", "FPos", "Time")) # row
  for(dTmp in dVec)
    for(dep in c("I", "D")){
      dfSub <- subset(df, measurement == mea & dependence == dep & d == dTmp)
      plt <- ggplot(data = dfSub, 
                    aes(x = n, y = val)) +
        geom_bar(position="dodge", stat="identity", mapping = aes(fill = mtd)) + 
        theme(text = element_text(size = 20), legend.title = element_blank(),
              legend.key.height = unit(3, 'cm'))
      if(mea == "CRPS")
        plt <- plt + ggtitle(paste0(dTmp,  " ",
                                    switch(which(dep == c("I", "D")), 
                                           "ind", "dep"), " pred"))
      if(dep != "I" | dTmp != dVec[1]){
        plt <- plt + theme(axis.title.y = element_blank())
      }else
        plt <- plt + ylab(mea)
      if(mea != "Time"){
        plt <- plt + 
          theme(axis.title.x = element_blank(), 
                axis.ticks.x=element_blank(), axis.text.x=element_blank())
      }
      if(exists("pltTtl")){
        pltTtl <- pltTtl + plt
      }else
        pltTtl <- plt
    }
pltTtl + plot_layout(ncol = 4, guides = "collect")
ggsave("sim_result_bar.pdf", height = 10, width = 14)
```


