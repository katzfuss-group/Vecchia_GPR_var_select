---
title: "main"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r clean environment}
rm(list = ls())
```

```{r libraries}
library(lhs)
library(mvtnorm)
library(scoringRules)
library(GpGp)
library(FNN)
library(purrr)
```

## Generate dataset

```{r locs gen func, eval = T}
locs_gen_idp <- function(n, d){
  locs <- randomLHS(n, d)
  locs * outer(rep(sqrt(n), n), 
               1 / sqrt(colSums(locs^2)))
}
locs_gen_dp <- function(n, d, rho){
  covM <- matrix(rho, d, d)
  diag(covM) <- 1
  locs <- rmvnorm(n, sigma = covM) 
  locs * outer(rep(sqrt(n), n), 
               1 / sqrt(colSums(locs^2)))
}
```

```{r gen piston obs func, eval = T}
source("piston_func.R")
Pist_gen <- function(locs){
  n <- nrow(locs)
  d <- ncol(locs)
  if(d < 7){
    stop("Piston function takes 7 covariates at least\n")
  }
  locsTmp <- apply(locs[, 1 : 7], 2, function(x){x - min(x) + 1})
  apply(locsTmp, 1, pistonfun)
}
```

```{r gen dataset, eval = T}
set.seed(123)
n <- 1e3 # commandArgs(trailingOnly = T)[1]
d <- 1e2 # commandArgs(trailingOnly = T)[2]
rho <- 0.9 # as.numeric(commandArgs(trailingOnly = T)[3])
kernel <- "piston" # commandArgs(trailingOnly = T)[4]
# homeDir <- commandArgs(trailingOnly = T)[5]
homeDir <- "~/Documents/penalized_vecchia_opt/CQCD_7.0_exp" 
if(rho != 0){
  locs <- locs_gen_dp(n, d, rho)
}else{
  locs <- locs_gen_idp(n, d)
}
if(kernel == "piston" || kernel == "Piston"){
  y <- Pist_gen(locs)
}else{
  stop("Kernel not defined\n")
}
```

```{r some opt parms, eval = T}
var0 <- 1
tau0 <- 1e-4
sr0 <- 1e-2
minPosi <- 1e-8
m <- 100
k <- 5
miniCQCD <- 128
miniGrad <- 128
lambVecBrdg <- 2^(rev(-10 : 4))
convCQCD <- 1e-4
convCCD <- 1e-4
cAmij <- 1e-4
maxIterCQCD <- 50
maxIterCCD <- 40
covFn <- "matern25_scaledim_sqrelevance"
mini <- T
taper <- F
silent <- F
```

```{r split dataset, eval = T}
splt_locs_y <- function(locs, y, p1, seed = NULL){
  if(!is.null(seed))
    set.seed(seed)
  n <- length(y)
  idx1 <- sample(1 : n, round(p1 * n))
  idx2 <- setdiff(1 : n, idx1)
  list(locs1 = locs[idx1, , drop = F], y1 = y[idx1], 
       locs2 = locs[idx2, , drop = F], y2 = y[idx2])
}
```

## OOS score computation

```{r OOS, eval = T}
OOS_score <- function(theta, locsTrnIn, locsTrnOut, yTrnIn, yTrnOut, m, 
                      covFn = "matern25_scaledim_sqrelevance")
{
  nIn <- nrow(locsTrnIn)
  d <- ncol(locsTrnIn)
  nOut <- nrow(locsTrnOut)
  idxLocsRel <- which(theta[2 : (d + 1)] > 0)
  dRel <- length(idxLocsRel)
  locsTrnInRel <- locsTrnIn[, idxLocsRel, drop = F]
  locsTrnOutRel <- locsTrnOut[, idxLocsRel, drop = F]
  thetaRel <- theta[c(1, idxLocsRel + 1, d + 2)]
  locsTrnInRelScal <- locsTrnInRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  locsTrnOutRelScal <- locsTrnOutRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  NNarray <- get.knnx(locsTrnInRelScal, locsTrnOutRelScal, m)$nn.index
  NNarray <- cbind(NNarray, (nIn + 1) : (nIn + nOut))
  locsRel <- rbind(locsTrnInRel, locsTrnOutRel)
  mus <- rep(NA, nOut)
  sds <- rep(NA, nOut)
  for(i in 1 : nOut){
    NN <- NNarray[i, ]
    K <- get(covFn)(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrnIn[NN[1 : m]])
    sds[i] <- L[m + 1, m + 1]
  }
  mean(crps_norm(y = yTrnOut, mean = mus, sd = sds))
}
```

## Stop conditions

```{r OOS 1% stop condition, eval = T}
stop_con_OOS1_path <- function(scrVec, idxSet, thetaSet)
{
  i <- length(scrVec)
  if(i < 2)
    return(-1)
  d <- length(thetaSet[[1]]) - 2
  if(scrVec[i] > scrVec[i - 1] * 0.99 &
     sum(thetaSet[[i - 1]][2 : (d + 1)]) > 0.1 &
     sum(thetaSet[[i]][2 : (d + 1)]) > 0.1)
    return(i - 1)
  else
    return(-1)
}
stop_con_OOS1_fb <- function(scrVec, idxSet, thetaSet)
{
  i <- length(scrVec)
  if(i < 2)
    return(-1)
  # from the 2nd iter, if SRs are still too small, stop crt fwd bwd selection
  # meaning that lambda is too big
  if(sum(thetaSet[[i - 1]][2 : (d + 1)]) < 0.1)
    return(i)
  d <- length(thetaSet[[1]]) - 2
  if(scrVec[i] > scrVec[i - 1] * 0.99 &
     sum(thetaSet[[i - 1]][2 : (d + 1)]) > 0.1 &
     sum(thetaSet[[i]][2 : (d + 1)]) > 0.1)
    return(i - 1)
  else
    return(-1)
}
```

## Vecchia regularization path

```{r Vecc_path, eval = T}

source(paste0(homeDir, "/CQCD.R"))
Vecc_path <- function(var0, tau0, sr0, locs, y, m, k, lambVec, pen_fun, 
                      dpen_fun, ddpen_fun, OOS_score, stop_con_path,
                      stop_con_fb, miniCQCD, miniGrad, pIn = 0.25, 
                      spltSeed = NULL, convCQCD = 1e-4, 
                      convCCD = 1e-4, cAmij = 1e-4, maxIterCQCD = 500, 
                      maxIterCCD = 40, covFn = "matern25_scaledim_sqrelevance", 
                      minPosi = 1e-8, mini = T, taper = F, silent = F)
{
  n <- nrow(locs)
  d <- ncol(locs)
  # init theta and idx
  rndIdx <- sample(1 : d, 1)
  theta <- c(var0, rep(0, d), tau0)
  theta[rndIdx + 1] <- sr0
  idx <- rndIdx
  # storage vars
  idxSet <- list()
  thetaSet <- list()
  scrVec <- c()
  # split locs and y
  spltObj <- splt_locs_y(locs = locs, y = y, p1 = pIn, seed = spltSeed)
  locsIn <- spltObj$locs1
  yIn <- spltObj$y1
  locsOut <- spltObj$locs2
  yOut <- spltObj$y2
  # loop over lambda
  for(i in 1 : length(lambVec)){
    lambda <- lambVec[i]
    if(!silent){
      cat("======================================================\n")
      cat("lambda =", lambda, "\n")
    }
    # re-init var and tau for each lambda
    theta[1] <- var0
    theta[d + 2] <- tau0
    # 1st level opt
    optObj <- fwd_bwd(idx = idx, theta = theta, sr0 = sr0, locsIn = locsIn, 
                      locsOut = locsOut, yIn = yIn, yOut = yOut, m = m, k = k, 
                      lambda = lambda, pen_fun = pen_fun, dpen_fun = dpen_fun, 
                      ddpen_fun = ddpen_fun, OOS_score = OOS_score, 
                      stop_con_fb = stop_con_fb, miniCQCD = miniCQCD, 
                      miniGrad = miniGrad, convCQCD = convCQCD, 
                      convCCD = convCCD, cAmij = cAmij, 
                      maxIterCQCD = maxIterCQCD, maxIterCCD = maxIterCCD, 
                      covFn = covFn, minPosi = minPosi, mini = T, taper = F, 
                      silent = F)
    # save results
    idxSet[[i]] <- optObj$idx
    thetaSet[[i]] <- optObj$theta
    scrVec[i] <- optObj$scr
    idx <- optObj$idx
    theta <- optObj$theta
    if(!silent){
      cat("Results for lambda =", lambVec[i], ":\n")
      cat("idx:", idxSet[[i]], "\n")
      cat("theta:", thetaSet[[i]][c(1, idxSet[[i]] + 1, d + 2)], "\n")
      cat("score:", scrVec[i], "\n")
    }
    # check stop
    iOpt <- stop_con_path(scrVec, idxSet, thetaSet)
    if(iOpt > 0)
      break
  }
  if(iOpt < 1)
    iOpt <- length(scrVec)
  if(!silent){
    cat("======================================================\n")
    cat("Results of Vecchia regularization path:\n")
    cat("lambda:", lambVec[iOpt], "\n")
    cat("idx:", idxSet[[iOpt]], "\n")
    cat("theta:", thetaSet[[iOpt]][c(1, idxSet[[iOpt]] + 1, d + 2)], "\n")
    cat("score:", scrVec[iOpt], "\n")
  }
  list(lambda = lambVec[iOpt], scr = scrVec[iOpt], idx = idxSet[[iOpt]], 
       theta = thetaSet[[iOpt]])
}

fwd_bwd <- function(idx, theta, sr0, locsIn, locsOut, yIn, yOut, 
                    m, k, lambda, pen_fun, 
                    dpen_fun, ddpen_fun, OOS_score, stop_con_fb, miniCQCD, 
                    miniGrad, convCQCD = 1e-4, convCCD = 1e-4, cAmij = 1e-4, 
                    maxIterCQCD = 500, maxIterCCD = 40, 
                    covFn = "matern25_scaledim_sqrelevance", 
                    minPosi = 1e-8, mini = T, taper = F, silent = F)
{
  d <- ncol(locsIn)
  # storage vars
  idxSet <- list()
  thetaSet <- list()
  scrVec <- c()
  iter <- 1
  # select kHat var each time
  while(length(idx) < d){
    if(!silent){
      cat("----------------------------------\n")
      cat("FB iter =", iter, "\n")
    }
    # gen lb for theta
    lb <- c(minPosi, rep(0, d), minPosi)
    lb[which.max(theta[2 : (d + 1)]) + 1] <- minPosi
    # MM and NN
    MMNNObj <- MM_NN(theta, idx, locsIn, yIn, lb, m)
    # CQCD
    CQCDObj <- CQCD_wrap(MMNNObj$thetaRel, MMNNObj$yOdr, MMNNObj$locsOdrRel, 
                         MMNNObj$NNarray, MMNNObj$lbRel, lambda, pen_fun, 
                         dpen_fun, ddpen_fun, convCQCD = convCQCD, 
                         convCCD = convCCD, cAmij = cAmij, 
                         maxIterCQCD = maxIterCQCD, maxIterCCD = maxIterCCD,
                         covFn = covFn, miniCQCD = miniCQCD, mini = mini, 
                         taper = taper, silent = silent)
    theta <- get_theta(CQCDObj$covparms, idx, d)
    idx <- idx[sapply(idx, function(i){theta[i + 1] > 0})]
    idxSet[[iter]] <- idx
    thetaSet[[iter]] <- theta
    scrVec[iter] <- OOS_score(theta = theta, locsTrnIn = locsIn, 
                                locsTrnOut = locsOut, yTrnIn = yIn, 
                                yTrnOut = yOut, m = m, covFn = covFn)
    if(!silent){
      cat("FB iter =", iter, "\n")
      cat("idx:", idxSet[[iter]], "\n")
      cat("theta:", thetaSet[[iter]][c(1, idxSet[[iter]] + 1, d + 2)], "\n")
      cat("score:", scrVec[iter], "\n")
    }
    # check stop
    iOpt <- stop_con_fb(scrVec, idxSet, thetaSet)
    if(iOpt > 0)
      break
    # compute grad
    gradObj <- comp_grad(theta = theta, locs = MMNNObj$locsOdr, y = MMNNObj$yOdr, 
                        NNarray = MMNNObj$NNarray, miniGrad = miniGrad, 
                        covFn = covFn)
    # select var
    kHat <- min(k, d - length(idx))
    odrGrad <- order(gradObj$grad[2 : (d + 1)], decreasing = T)
    idxSel <- setdiff(odrGrad, idx)[1 : kHat]
    idx <- c(idx, idxSel)
    # init new var
    theta[idxSel + 1] <- sr0
    # next iter
    iter <- iter + 1
  }
  if(!silent){
    cat("----------------------------------\n")
  }
  if(iOpt < 1)
    iOpt <- length(scrVec)
  list(scr = scrVec[iOpt], idx = idxSet[[iOpt]], theta = thetaSet[[iOpt]])
}

get_theta <- function(thetaRel, idx, d)
{
  theta <- rep(0, d + 2)
  theta[c(1, idx + 1, d + 2)] <- thetaRel
  theta
}

comp_grad <- function(theta, locs, y, NNarray, miniGrad, 
                     covFn = "matern25_scaledim_sqrelevance")
{
  n <- nrow(NNarray)
  batchIdx <- sample(x = 1 : n, size = miniGrad, replace = F)
  vecchia_meanzero_loglik_grad_info(theta, covFn, y, locs, 
                                    NNarray[batchIdx, , drop = F])
}

MM_NN <- function(theta, idx, locs, y, lb, m)
{
  n <- nrow(locs)
  d <- ncol(locs)
  dHat <- length(idx)
  locsRel <- locs[, idx, drop = F]
  locsRelScal <- locsRel %*% diag(sqrt(theta[1 + idx]), dHat, dHat)
  odr <- order_maxmin(locsRelScal)
  yOdr <- y[odr]
  locsRelScalOdr <- locsRelScal[odr, , drop = F]
  locsOdr <- locs[odr, , drop = F]
  locsOdrRel <- locsOdr[, idx, drop = F] 
  NNarray <- GpGp::find_ordered_nn(locsRelScalOdr, m = m)
  thetaRel <- theta[c(1, idx + 1, d + 2)]
  lbRel <- lb[c(1, idx + 1, d + 2)]
  list(locsOdr = locsOdr, locsOdrRel = locsOdrRel, yOdr = yOdr, 
       thetaRel = thetaRel, lbRel = lbRel, NNarray = NNarray)
}

CQCD_wrap <- function(theta, y, locs, NNarray, lb, lambda, 
                      pen_fun, dpen_fun, ddpen_fun, 
                      convCQCD = 1e-4, convCCD = 1e-4, cAmij = 1e-4, 
                      maxIterCQCD = 500, maxIterCCD = 40,
                      covFn = "matern25_scaledim_sqrelevance",
                      miniCQCD = 128, mini = T, taper = F, silent = F)
{
  n <- nrow(locs)
  if(mini){
    if(taper){
      objfun <- function(theta, batchIdx, thetaAvg, iter){
        likObj <- vecchia_meanzero_loglik(theta, covFn, y, locs, 
                                          NNarray[batchIdx, , drop = F])
        likObj$loglik <- likObj$loglik - pen_fun(thetaAvg, lambda, iter)
        likObj
      }
      objfun_gdfm <- function(theta, batchIdx, thetaAvg, iter){
        likObj <- vecchia_meanzero_loglik_grad_info(theta, covFn, y, locs,
                                                    NNarray[batchIdx, , 
                                                            drop = F])
        likObj$loglik <- likObj$loglik - pen_fun(thetaAvg, lambda, iter)
        likObj$grad <- likObj$grad - dpen_fun(thetaAvg, lambda, iter)
        likObj$info <- likObj$info + ddpen_fun(thetaAvg, lambda, iter)
        likObj
      }
      CQCD_stochastic_taper(objfun, objfun_gdfm, n, miniCQCD, 
                            theta, lb = lb, convtolOut = convCQCD, 
                            convtolIn = convCCD, maxIterOut = maxIterCQCD,
                            maxIterIn = maxIterCCD, cAmij = cAmij, 
                            silent = silent)
    }else{
      objfun <- function(theta, batchIdx){
        likObj <- vecchia_meanzero_loglik(theta, covFn, y, locs, 
                                          NNarray[batchIdx, , drop = F])
        likObj$loglik <- likObj$loglik - pen_fun(theta, lambda)
        likObj
      }
      objfun_gdfm <- function(theta, batchIdx){
        likObj <- vecchia_meanzero_loglik_grad_info(theta, covFn, y, locs,
                                                    NNarray[batchIdx, , 
                                                            drop = F])
        likObj$loglik <- likObj$loglik - pen_fun(theta, lambda)
        likObj$grad <- likObj$grad - dpen_fun(theta, lambda)
        likObj$info <- likObj$info + ddpen_fun(theta, lambda)
        likObj
      }
      CQCD_stochastic(objfun, objfun_gdfm, n, miniCQCD, 
                      theta, lb = lb, convtolOut = convCQCD, 
                      convtolIn = convCCD, maxIterOut = maxIterCQCD,
                      maxIterIn = maxIterCCD, cAmij = cAmij, 
                      silent = silent)
    }
  }else{
    stop("CQCD_wrap with mini = F is not implemented yet\n")
  }
}
```

```{r bridge penalty, eval = T}
pen_brdg <- function(theta, lambda){
  lambda * sum(theta[-c(1, length(theta))]^(0.25))
}
dpen_brdg <- function(theta, lambda){
  r <- theta[-c(1, length(theta))]
  rpen <- lambda * r^(0.25 - 1) * 0.25
  rpen[r < 1e-20] <- lambda * (1e-20)^(0.25 - 1) * 0.25
  c(0, rpen, 0)
}
ddpen_brdg <- function(theta, lambda){
  diag(rep(0, length(theta)))
}
```

## Parms est and var select

```{r split Train and Test, eval = T}
spltObj <- splt_locs_y(locs, y, 0.75, 123)
locsTrn <- spltObj$locs1
yTrn <- spltObj$y1
locsTst <- spltObj$locs2
yTst <- spltObj$y2
pIn = max(1 - 5e3 / n, 0.75)
rm(spltObj, locs, y)
```

```{r Vecc_path parms est and var select, eval = T}
Vecc_path(var0 = var0, tau0 = tau0, sr0 = sr0, locs = locsTrn, y = yTrn, 
          m = m, k = k, lambVec = lambVecBrdg, pen_fun = pen_brdg, 
          dpen_fun = dpen_brdg, ddpen_fun = ddpen_brdg, OOS_score = OOS_score,
          stop_con_path = stop_con_OOS1_path, stop_con_fb = stop_con_OOS1_fb, 
          miniCQCD = miniCQCD, miniGrad = miniGrad, pIn = pIn, spltSeed = 123,
          convCQCD = convCQCD, convCCD = convCCD, cAmij = cAmij, 
          maxIterCQCD = maxIterCQCD, maxIterCCD = maxIterCCD, covFn = covFn, 
          minPosi = minPosi, mini = mini, taper = taper, silent = silent)
```







































