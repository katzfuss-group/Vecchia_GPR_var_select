---
title: "Fisher scoring"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Method 
Use scaled Vecchia and Fisher scoring. 

## Preparation
Clean the environment
```{r clean environment}
rm(list = ls())
```
Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
library(GpGp)
library(FNN)
library(scoringRules)
if(file.exists("CQCD.R")){
  source("CQCD.R")
}else{
  source("../CQCD.R")
}
args <- commandArgs(trailingOnly = T)
if(length(args) != 4)
  stop("Wrong number of input args\n")
dataInFile <- args[1]
fileID <- args[4]
if(file.exists(dataInFile)){
  load(dataInFile)
}else{
  load(paste0("../../sim_study_data_gen/", dataInFile))
}
source("fisher_scoring.R")
set.seed(123)
```
Divide observations.
```{r divide GP obs, eval = T}
m <- 100
k <- 3
nOOS <- 5e3
nTest <- 5e3
nTrain <- as.numeric(args[2])
dTrain <- as.numeric(args[3])
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsOOS <- locs[(nTrain + 1) : (nTrain + nOOS), 1 : dTrain, drop = F]
locsTest <- locs[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest), 1 : dTrain, 
                 drop = F]
yTrain <- y[1 : nTrain]
yOOS <- y[(nTrain + 1) : (nTrain + nOOS)]
yTest <- y[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest)]
```
Function for computing the approximate OOS score, assuming the squared relevance parameterized Matern25 kernel.
```{r OOS score, eval = T}
OOS_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsOOS)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yOOS)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nOOS), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nOOS))
  mus <- rep(NA, nOOS)
  sds <- rep(NA, nOOS)
  for(i in 1 : nOOS){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yOOS, mean = mus, sd = sds))
}
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsTest)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yTest)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nTest), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nTest))
  mus <- rep(NA, nTest)
  sds <- rep(NA, nTest)
  for(i in 1 : nTest){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yTest, mean = mus, sd = sds))
}
```

## Method specific

Link and response transforms
```{r link and response, eval = T}
link_func <- log
resp_func <- exp
dresp_func <- exp
```
Function for model fitting given predictor indices. `theta` stores the warm-start values after **transformation**. 
```{r model fit, eval = T}
maxIter <- 100
model_fit <- function(locsIdx)
{
  locsFit <- locsTrain[, locsIdx, drop = F]
  thetaFit <- theta[c(1, locsIdx + 1, dTrain + 2)]
  crtIter <- 1
  ttlIter <- 0
  while(TRUE)
  {
    locsFitScal <- locsFit %*% 
        diag(sqrt(resp_func(thetaFit[2 : (1 + length(locsIdx))])), 
             length(locsIdx), length(locsIdx))
    odr <- order_maxmin(locsFitScal)
    yOdr <- yTrain[odr]
    locsFitScalOdr <- locsFitScal[odr, , drop = F]
    locsFitOdr <- locsFit[odr, , drop = F]
    NNarray <- GpGp::find_ordered_nn(locsFitScalOdr, m = m)
    
    objfun <- function(thetaTrans){
      likobj <- 
        vecchia_meanzero_loglik_grad_info(resp_func(thetaTrans), 
                                          "matern25_scaledim_sqrelevance",
                                          yOdr, locsFitOdr, 
                                          NNarray)
        likobj$loglik <- -likobj$loglik
        likobj$grad <- -c(likobj$grad) * dresp_func(thetaTrans)
        likobj$info <- likobj$info * outer(dresp_func(thetaTrans),
                                           dresp_func(thetaTrans))
        return(likobj)
    }
    
    FisherObj <- fisher_scoring(objfun, thetaFit, resp_func, F, 1e-4, crtIter)
    thetaFit <- FisherObj$logparms
    ttlIter <- ttlIter + crtIter
    crtIter <- min(2 * crtIter, maxIter - ttlIter)
    if(ttlIter == maxIter)
      break
  }
  OOSScore <- OOS_score(theta = resp_func(thetaFit), idxLocsRel = locsIdx)
  list(theta = thetaFit, score = OOSScore)
}
```

Init `theta`.
```{r Init theta, eval = T}
# theta <- get_start_parms(yTrain, sample(c(-1, 1), nTrain, replace = T), 
#                          locsTrain, "matern25_scaledim")$start_parms
# theta[2 : (dTrain + 1)] <- (1 / theta[2 : (dTrain + 1)])^2
theta <- c(0.25, rep(0.01, dTrain), 0.01)
  
idxSet <- list()
thetaSet <- list()
scoreSet <- list()
selectIdx <- c()
```
Loop over lambda.
```{r loop over lambda, eval = T}
startTime <- Sys.time()

model <- model_fit(c(1 : dTrain))
# Store results
i <- 1
idxSet[[i]] <- which(resp_func(model$theta[2 : (dTrain + 1)]) > 1e-7) + 1
thetaSet[[i]] <- resp_func(model$theta)
scoreSet[[i]] <- model$score

endTime <- Sys.time()
timeObj <- endTime - startTime
timeObj
```

```{r save the result, eval = T}
if(grepl("dep", dataInFile, ignore.case = T)){
  dataOutFile <- paste0("Fisher_scoring_dep_", fileID, "_", nTrain, "_", 
                        dTrain, ".RData")
}else
  dataOutFile <- paste0("Fisher_scoring_", fileID, "_", nTrain, "_", dTrain, 
                        ".RData")
save(list = c("dTrain", "idxSet", "thetaSet", "scoreSet",
              "nTrain", "timeObj"), 
     file = dataOutFile)
```
