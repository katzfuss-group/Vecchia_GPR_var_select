---
title: "Fisher scoring"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Method 
Use scaled Vecchia and Fisher scoring. 

## Preparation
Clean the environment
```{r clean environment}
rm(list = ls())
```
Need to install a modified version of the GpGp R package.
```{r install the moderated GpGp Pkg}
devtools::install_github("https://github.com/SamCao1991/GpGp.git")
library(GpGp)
library(FNN)
library(scoringRules)
if(file.exists("CQCD.R")){
  source("CQCD.R")
}else{
  source("../CQCD.R")
}
if(file.exists("data_35000.RData")){
  load("data_35000.RData")
}else{
  load("../../sim_study_data_gen/data_35000.RData")
}
source("fisher_scoring.R")
set.seed(123)
```
Divide observations.
```{r divide GP obs, eval = T}
m <- 100
k <- 3
nOOS <- 5e3
nTest <- 5e3
nTrain <- 5e2
dTrain <- 1e3
locsTrain <- locs[1 : nTrain, 1 : dTrain, drop = F]
locsOOS <- locs[(nTrain + 1) : (nTrain + nOOS), 1 : dTrain, drop = F]
locsTest <- locs[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest), 1 : dTrain, 
                 drop = F]
yTrain <- y[1 : nTrain]
yOOS <- y[(nTrain + 1) : (nTrain + nOOS)]
yTest <- y[(nTrain + nOOS + 1) : (nTrain + nOOS + nTest)]
```
Function for computing the approximate OOS score, assuming the squared relevance parameterized Matern25 kernel.
```{r OOS score, eval = T}
OOS_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsOOS)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yOOS)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nOOS), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nOOS))
  mus <- rep(NA, nOOS)
  sds <- rep(NA, nOOS)
  for(i in 1 : nOOS){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yOOS, mean = mus, sd = sds))
}
```

Function for computing the test score, assuming the squared relevance parameterized Matern25 kernel.
```{r test score, eval = T}
test_score <- function(thetaRel, idxLocsRel)
{
  dRel <- length(idxLocsRel)
  locsRel <- rbind(locsTrain, locsTest)[, idxLocsRel, drop = F]
  locsRelScal <- locsRel %*% 
    diag(sqrt(thetaRel[2 : (dRel + 1)]), dRel, dRel)
  yTtl <- c(yTrain, yTest)
  NNarray <- get.knnx(locsRelScal[1 : nTrain, , drop = F],
                      locsRelScal[(nTrain + 1) : (nTrain + nTest), , drop = F], 
                      m)$nn.index
  NNarray <- cbind(NNarray, (nTrain + 1) : (nTrain + nTest))
  mus <- rep(NA, nTest)
  sds <- rep(NA, nTest)
  for(i in 1 : nTest){
    NN <- NNarray[i, ]
    K <- matern25_scaledim_sqrelevance(thetaRel, locsRel[NN, , drop = F])
    L <- t(chol(K))
    mus[i] <- L[m + 1, 1 : m] %*% 
      forwardsolve(L[1 : m, 1 : m], yTrain[NN[1 : m]])
    sds[i] <- L[m+1, m+1]
  }
  mean(crps_norm(y = yTest, mean = mus, sd = sds))
}
```

## Method specific

Link and response transforms
```{r link and response, eval = T}
link_func <- log
resp_func <- exp
dresp_func <- exp
```
Function for model fitting given predictor indices. `theta` stores the warm-start values after **transformation**. 
```{r model fit, eval = T}
maxIter <- 100
model_fit <- function(locsIdx)
{
  locsFit <- locsTrain[, locsIdx, drop = F]
  thetaFit <- theta[c(1, locsIdx + 1, dTrain + 2)]
  locsFitScal <- locsFit %*% 
      diag(sqrt(resp_func(thetaFit[2 : (1 + length(locsIdx))])), 
           length(locsIdx), length(locsIdx))
  odr <- order_maxmin(locsFitScal)
  yOdr <- yTrain[odr]
  locsFitScalOdr <- locsFitScal[odr, , drop = F]
  locsFitOdr <- locsFit[odr, , drop = F]
  NNarray <- GpGp::find_ordered_nn(locsFitScalOdr, m = m)
  
  objfun <- function(thetaTrans){
    likobj <- 
      vecchia_meanzero_loglik_grad_info(resp_func(thetaTrans), 
                                        "matern25_scaledim_sqrelevance",
                                        yOdr, locsFitOdr, 
                                        NNarray)
      likobj$loglik <- -likobj$loglik
      likobj$grad <- -c(likobj$grad) * dresp_func(thetaTrans)
      likobj$info <- likobj$info * outer(dresp_func(thetaTrans),
                                         dresp_func(thetaTrans))
      return(likobj)
  }
  
  FisherObj <- fisher_scoring(objfun, thetaFit, resp_func, F, 1e-4, maxIter)
  thetaFit <- FisherObj$logparms
  OOSScore <- OOS_score(theta = resp_func(thetaFit), idxLocsRel = locsIdx)
  list(theta = thetaFit, score = OOSScore)
}
```

Init `theta`.
```{r Init theta, eval = T}
theta <- link_func(c(0.25, rep(1.0, dTrain), 0.01))
idxSet <- list()
thetaSet <- list()
scoreSet <- list()
selectIdx <- c()
```
Loop over lambda.
```{r loop over lambda, eval = T}
startTime <- Sys.time()

model <- model_fit(c(1 : dTrain))
# Store results
i <- 1
idxSet[[i]] <- which(resp_func(model$theta[2 : (dTrain + 1)]) > 1e-7) + 1
thetaSet[[i]] <- resp_func(model$theta)
scoreSet[[i]] <- model$score

endTime <- Sys.time()
timeObj <- endTime - startTime
timeObj
```

```{r save the result, eval = T}
save(list = c("dTrain", "idxSet", "thetaSet", "scoreSet",
              "nTrain", "timeObj"), 
     file = paste0("Fisher_scoring_", nTrain, "_", dTrain, ".RData"))
```
